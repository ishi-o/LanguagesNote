### 官方文档风格

- 中括号表示可选项参数(`C++`中的可变参数)：例如`del A[, B[, ...[, X]]]`表示`del`可接多个变量
- `python`是面向对象的脚本语言，支持默认参数；通常用`C++`风格或`**`后接字典风格表示传递参数

### 包/模块管理

- 与`java`类似，一个文件夹即称为包(`3.3`后不需要`__init__.py`文件即可被识别为包)
  一个`.py`文件称为模块
  每个包/模块有自己的命名空间(命名空间名与文件夹/文件名一致)
- 不同模块间调用函数，需要**`import package/module`或`from package_name import module_name`或`from module_name import method_name`**来引入
  可通过`'.'`操作符快速定位模块
  可通过`as`关键字为包/模块改名

### 标识符与语句风格

- 标识符命名习惯：与其他语言类似；此外，解释器会对一些类中的习惯性命名特殊处理：

  - **`_xxx`：作为保护属性/方法**的约定俗成的命名，**不会被特殊处理**，也就不是真正的“保护型”
  - **`__xxx`：作为私有属性/方法**，类外无法直接访问，原理见[Python 私有属性 博客园](https://www.cnblogs.com/caimengzhi/p/8522002.html)
  - **`__xxx__`：语言本身内置的特殊方法**，虽然是双下划线开头，但与私有方法不同

- 一条语句无需添加`;`
  需要将一条语句分割为多行时，用`'\'`分割
  括号内的内容可直接分割为多行

- 赋值语句：**可用一条语句为多个变量赋值**，原理是会将右值转换为元组，然后根据下列特性：
  若字面量为序列，且变量有多个(必须和序列长度相等)，则一一对应进行赋值

  ```python
  a, b = 1, 2		# a = 1、b = 2		后面的1, 2被转换为元组再赋值给a, b
  a, b = [1, 2]	# a = 1、b = 2		
  ```
  
- 语句块不使用大括号限定范围，而是通过**缩进**表示，同级语句块内所有语句缩进长度应相同
  在习惯上，通常在不同的函数/类间添加空行，方便维护代码

- 单行注释：`'#'`后的所有内容为注释

- 字符串字面量：单引号、双引号均可(方便在内部不通过转义字符也能表示单/双引号)
  通过`'''`或`"""`可表示**文档字符串**(`docstring`，也称多行字符串)，由于字面量不赋值给变量时，会被解释器无视，因此可用作**多行注释**(官方不推荐)

- 条件语句：表达式`expression`无需括号(区分优先级时可使用括号)，在表达式/关键字后需添加`':'`
  其它语句也类似

  ```python
  if expression :
      statement
  elif expression :
      statement
  ...elif...
  else :
  	statement
  ```

- 循环语句：

  - `while`语句与其它语言类似，可在`while`后添加`else`进行退出循环时的操作
  - `for 迭代器 in 序列`语句使用迭代器迭代`in`后的序列，可在`for`后添加`else`进行退出循环时的操作
    关键字`break`、`continue`用法与`C`一致
  - 有助于`for`循环的一些函数：`range()、enumerate()、zip()`以及所有返回迭代器的函数

- 逻辑运算符：`and、or、not`

- 其它关键字：`with-as、try-finally`

### 数据类型及字面量

- `python`是一种**动态、强类型**的脚本语言，动态即声明变量时**不需要指定数据类型**而是由解释器判断

  但区分于`js`等弱类型的脚本语言，表达式中**不允许隐式类型转换**，且运行时进行**严格的类型检查**而非自动转换，出错时抛出异常

- 区分于`java,C`等语言，`python`的所有类型均为所谓“引用”类型(数据存储在堆中，栈中存储指向数据的指针)
  但有不可变类型和可变类型之分：

  - 不可变类型：类似`java`的常量池，一份不可变类型的数据**可被多个对象指向**
    用户**不能修改**该类对象的**内部**数据，但可以修改对象的引用(赋值)来达成修改对象内容的目的
    当用户**对该类对象赋值**时，查询缓存中是否含有目标数据(不存在则**自动创建**)，并使该对象的**引用指向目标数据**(对象的引用改变，对其它指向原数据的对象无影响)

  - 可变类型：一份可变类型的数据**可被多个对象指向**
    当用户修改对象内部数据时，将**直接修改数据**(对象的引用不变，数据改变，对所有指向原数据的对象有影响)
    若希望不影响相关联对象，需**用构造函数创建**并将其引用赋值给目标对象，再修改数据
    
  - `is/is not`：判断两边引用是否指向同一对象，可通过此运算符理解不可变/可变类型的差距

  - `del`：所有变量均可由`del`关键字删除其引用，其指向的资源由`GC`管理

- 标准数据类型：

  - 数字类型：`int`、`long`、`float`、`complex`(复数)，均为不可变类型
    更多数学运算函数在`math`库中
  - 字符串`str`：为**不可变**的`Unicode`字符**序列**
  - **列表`list`**：为**可变**的有序**序列**，不同项类型可不同，**用`[]`快速创建**
  - **元组`tuple`**：为**不可变的列表**，用户无法通过索引修改内部数据，**用`()`快速创建**
    可能存在使用元组存储可变类型元素的情况，此时元组为可变类型
    
    有关列表和元组，类似`java`中的`StringBuilder`和`String`，这就是最典型的不可变/可变类型的区别
  - 集合`set`：为可变的无序集合，类似`C++`中的`unordered_set`，**用`{}`快速创建**
  - **字典`dict`**：为可变的无序集合，元素为键值对`key:val`，**`key`**必须为**不可变**类型，**用`{}`快速创建**
    字典与其它序列/集合通过自然数索引元素不同，通过键索引，返回对应的值

- 类型转换的内置函数：

  - `str()`和`repr()`：将对象转换为字符串；前者要求更强的可读性(方便使用)、后者要求更强的准确性(方便调试)
    解释器在进行类型转换时，先找`str()`，再找`repr()`；类中应至少实现一种
  - `eval()`：将字符串转换为解释器可运行的表达式(不是语句而是表达式)
    例如`a = 1 + 2`等同于`a = eval("1+2")`
  - `chr()`和`ord()`：整数转`ASCII`字符、`ASCII`字符转十进制数


### 序列/集合操作

- 字符串、列表、元组等均为序列，均可用类似于`Matlab`的`[]`语法查询序列内容
  可变序列可通过`[]`二次赋值
  - 索引操作符：`[N]`表示查询第`N`项内容，下标从零算起，可以使用负数下标表示倒数项(`-1`表示最后一项)
  - **切片操作符**：`[B:E:S]`表示截取序列的第`B`项到第`E-1`项，下标可为空表示取到尽头
    `S`为可选参数，表示步长为`S`的截取；默认为`1`，即无间隔截取
  - 切片对象：`slice(B, E[, S])`，用于创建切片，切片性质与上述操作符类似
    通过`seq[slice_obj]`可实现与切片操作符一致的效果(传递`None`以表示空)
- 用于序列的内置的运算符重载：`+`表示序列的拼接、`*`表示序列的重复拼接
- `elem [in/not in] seq/set`：返回布尔值，查询`elem`在/不在`seq`序列或`set`集合中
- 其它全局函数：`len()、max()、min()、sum()、sorted()、reversed()、enumerate()`
  - `sorted()`：表示原序列的升序排序后副本
  - `reversed()`：返回反向迭代器
  - `enumerate()`：返回二元组`(idx,val)`构成的序列，通常用于循环
- 其它通用的序列方法：`count()、index()`
- 其它可变序列的方法：`append()、extend()、insert()、pop()、remove()、reverse()、sort()`
- 其它字符串的方法：`find()、format()、replace()、split()、strip()、translate()`
- 字典的方法：`clear()、copy()、get()、has_key()、items()、pop()、remove()、update()`

### 一般函数

- 定义函数：

  ```python
  def func ( params ) :
      ...
      return			# 返回空可不写return
  ```

  **参数使用浅拷贝**，若为可变类型的传参，需注意引用的修改
  函数名`func`本身是函数对象，其引用指向语句块，可赋值给其它变量、也可修改`func`指向的函数
  
- 参数类型：设定参数时无需指定类型，可以设置**默认参数/可变参数**
  调用时，可指定某参数的值，称为**关键字参数**

  ```python
  def func (p1, p2 = default, *p3):
  	return
  
  func(p2 = 2, p1 = 1)
  ```

  其中在`def`行，`p2`为默认参数，`p3`为可变参数(不定长参数，是一个元组)，用于存储所有多余的(即除了前面必须传输的参数外，额外的)形参
  在调用行，指定了`p1`为`1`、`p2`为`2`，为关键字参数调用

- 类型注解：仅有助于阅读代码
  ```python
  def func() -> type:
      return type_obj
  ```

  可主动指出返回类型，但**解释器不会检查**，若返回的对象和`type`类型不一致也不会报错

- 匿名函数：
  ```python
  namedfunc = lambda params : expression
  ```

  `lambda`为创建函数对象的关键字，`params`为可选项，用于在`expression`中使用
  该语句将`lambda`创建的匿名函数的引用赋值给`namedfunc`，此后可以通过`namedfunc(params)`调用该匿名函数
  因此和`C++`内联函数那样的编译时文本替换不同，匿名函数也属于`function`类，和`def`定义的函数一样会占用内存、可以赋值给其它变量、修改引用

### 面向对象编程

- 类与方法的标准定义：

  ```python
  class Clsname :
      '''docstring'''		# 类说明
      var1 = 1			# 公有变量
      _var2 = 1			# 保护变量
      __var3 = 1			# 私有变量
      
      # 构造方法, 一般__xxx__均为内置方法, 可重写并由解释器处理
      def __init__(self, ...):
          ...
          
  class SubCls (Cls1[, Cls2[, ...]]):	# 子类声明, 允许多继承
  ```

  其中所有实例方法至少声明一个参数，首个参数表示实例对象的引用(类似`this`)(习惯命名为`self`，其它命名也可)
  其作为隐式参数(类方法中也有)，调用时由解释器自动传递，无需显式传递

- 描述符协议：

- 内置根类：`object`

  - 所有类直接或间接地继承`object`类，调用未重载的内置类方法时，默认直接或间接地使用其提供的方法，常见有：
    <img src="D:\桌面\Study\语言\Python\MD\pictures\object_method.png" style="zoom: 35%;" />

- **静态方法、类方法**：

  - 静态方法由`staticmethod`类(一个实现了上述描述符协议的类)实现，并由语法糖`@staticmethod`隐藏其细节
    通过用`@staticmethod`修饰来创建一个静态方法，因上述类的控制而不会传递任何隐式参数(或者说首个参数不会被看作`self`)
    其与`C++`的静态方法不同，它**不能访问任何类的属性、方法**
    它不依靠类来实现它的功能，类需要它的功能因此挂靠在类中方便实现类的功能
    静态方法是最接近一般函数的方法，和类的关系仅有一个语法糖的绑定
  - 类方法由`classmethod`类实现，并由语法糖`@classmethod`隐藏其细节
    通过用`@classmethod`修饰来创建一个类方法，因上述类的控制会将首个参数视为`cls`(该参数的常用命名)而不是`self`(指实例的引用)，因此也只能访问类属性
    `cls`指向最早调用该方法的类(源头)
    可以通过`cls`来直接控制类属性
  - <img src="D:\桌面\Study\语言\Python\MD\pictures\example_staticmethod.png" style="zoom: 35%;" />
    静态方法不会将首个参数视为隐式参数

- **实例属性、实例方法**：

  - 实例属性区分于类属性(在类内定义的属性)，是绑定于具体实例的
    可在类外、实例方法内创建实例属性：`实例名.实例属性名=内容`
    一个实例无法访问其它实例的实例属性
    **所有和类/对象绑定的属性，都需要用点操作符访问**(即使在类内访问)
    有个细节是，**如果通过实例访问类属性，解释器会优先解释为用户试图创建一个(和类属性同名的)新的实例属性**，例如：
    
    ```python
    class A:
        a = 1
        
    a = A()
    b = A()
    a.a = 2
    print(a.a, b.a)		# 输出 2 1
    ```
    
    所以尽量不要通过实例访问类属性，以免导致混乱哦
  - 还可以通过`MethodType()`将一个一般函数绑定给实例属性(和普通的实例方法不同，这样绑定的方法对其它实例无效)，当然，要注意显式地声明`self`
    ```python
    from types import MethodType
    def func(self):
        return 1
    a = Cls()
    a.fff = MethodType(func, a)		# 将func()绑定给a
    a.fff()
  - 实例方法就是不加任何语法糖修饰的，类内定义的方法
    它可以访问实例属性(通过`self`访问，访问一个实例属性前，需保证`self`已经有该实例属性的定义)、类属性

- **`super`类**：用于调用父类的方法，若为多继承则会以`MRO`策略查找目标方法，保证只会调用仅一个父类的同名方法；其构造方法为`super([type[, type-or-obj]])`
  如果子类**没有显式重载**，调用父类方法时，解释器会**自动调用`super()`**

  - `super()`：`python3`支持不带参数，在类中使用时解释器根据所在方法类型自动隐式传递参数
    若在实例方法中，将传递`(type, self/cls)`，可以通过`super()`调用父类任意(非私有)方法
    若在类方法中，将传递`(type, cls)`，不能通过`super()`调用父类的实例方法
  - `super(type)`：只传递一个参数，返回的对象不绑定任何类/对象，使用它调用方法将报错
  - `super(type, obj)`：返回的代理对象绑定`obj`，调用某方法时，查找`type`的`MRO`；`obj`必须是`type`的实例(或`type`子类的实例)，因为通过代理对象调用方法时将传递`obj`作为`self`
  - `super(type1, type2)`：返回的代理对象绑定`type2`，调用某方法时，查找`type1`的`MRO`；后者必须是前者的子类，因为通过代理对象调用方法时将传递后者作为`cls`
  - 可以通过调用`mro()`查看方法解析顺序(返回一个列表)
    一般来说，先找本类，再找继承顺序(广度优先)

- 内置类方法(基础方法/重载方法)：

  - `__new__(cls)`：**静态方法**，创建一个所有属性均为空的实例，返回这个实例的引用
    一般不用重载，解释器会自动调用`super().__new__()`直到找到有重载的父类/找到`object`类
    需要重载的情况：实现**单例模式**(只允许有一个实例存在)

    ```python
    class Cls:
        __instance = None
    
        def __new__(cls):
            if Cls.__instance:			# 若存在, 则拦截, 不让解释器调用__new__()
                return Cls.__instance
            Cls.__instance = super().__new__(cls)
            return Cls.__instance

  - **`__init__(self)`**：实例方法，由用户决定如何初始化类属性、实例属性(或调用父类的`init`)
    更像一般意义的构造方法，解释器构造实例先调用`__new__()`再将其返回的实例隐式传递给`__init__()`

  - `__del__()`

  - `__iter__()、__next__()、__getitem__()、__setitem__()、__delitem__()`

  - `__getattribute__()、__getattr__()、__setattr__()、__delattr__()`

  - `__enter__()、__exit__()`

  - 描述符协议方法

- 内置类属性：

  - `__dict__`：由类的所有属性组成的`mappingproxy`，只读的字典
    这里要区分和实例的`__dict__`，通过类访问`__dict__`是类属性
    而通过实例访问的`__dict__`是一个可读写的字典，以便用户可以随意创建实例属性
  - `__doc__`：文档字符串，作为注释使用
  - `__bases__`：由所有父类组成的元组
  - `__slots__`：由字符串组成的元组，限制所有实例能够创建的实例属性
    一旦声明了这个类属性，所有实例都不再拥有`__dict__`了，因为它们的功能是冲突的

- 新式类和经典类：新式类指`Python3`中的类，上述类相关语法均为新式类，和经典类有若干区别

- 抽象基类：

- 多态/鸭子类型：`python`是动态语言，因此与静态语言相比更加普遍而灵活，因为它不要求参数必须是某个类/子类的实例，所以可以实现**不依赖继承**关系的多态效果
  即，只要不同的类均实现了同一个方法，尽管没有继承关系，也可以作为参数传递给函数/方法并调用实现了的方法
  解释器不关心对象是谁的儿子，只关心执行一条语句时，能否在对象所属类找到这个方法

### 垃圾回收

### 异常处理
